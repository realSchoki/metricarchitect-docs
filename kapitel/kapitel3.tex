% kapitel3.tex
\chapter{Challenge and Approach}
\label{chapter:bestandsaufnahme}
To start a proper analysis and abstraction of the problem a starting example is needed. It is important to qualify the rules which describe how the system is build and realize the dependencies. Furthermore, because of the importance of \gls{promql} in this project it will be a big part of the analysis and model.
\section{Examples}
Because it is already known which software to use this section will be split into smaller sections for the sake of clarity. 

\subsection{Real World Situation}
In this section the properties of the system that are observable in the real world are considered closer. Sensors come in different shapes and varieties. For example single metric sensors, like thermometer, brightness sensors or power consumption. 

Additionally there are also more complex ones. Multi metric sensors for example are digital weather stations, network components like a switch or router, server metrics and so on. A specific property, which only real world sensors can have, is a location. They can be in the living room or an office building. If the whole sensor network is between multiple cities and multiple with a humidity sensor on each floor in every room it can become rather large in scale.

Summarized it is a real world gadget which provide at least one metric and is somehow bound to a location.

\subsection{Digital World}
Because the sensors are more intelligent devices in this context they have to be accessible through network via \gls{IPv4} or \gls{IPv6} and expose the metrics in a predefined syntax ( see section \ref{subsec:Exportformat}, page \pageref{subsec:Exportformat} ). 

This is the bridge to the consuming parts of the system. In the next step Prometheus is configured to actively pull the exposed metrics of the sensors in a predefined frequency. It is the possible for the sensors to push their metrics to Prometheus, but it would cause the sensors have to be configured knowing  Prometheus \gls{ip-address}. The way of pushing the data into Prometheus won't be examined further.

Since Prometheus only acts as the database, Grafana is used as a visualization toolkit. Grafana connects directly to Prometheus and uses \gls{promql} to gather information from the database storage. The possibilities mentioned in \autoref{sec:grafana} are configurable. 

Both settings for Prometheus and Grafana can be delivered with a simple configuration file, meaning there is no need to go through the setup process. 
In addition a Dockerfile will take care of the correct packaging and runtime accessibility of all needed files. Therefore this whole structure makes allows to get a single output which is capable of running Prometheus and Grafana, configured in the predefined way and already knowing the set up sensor devices.

\begin{figure}
	\centering
	\begin{tikzpicture}[n/.style={draw,thick,circle,inner sep=0pt,minimum width=1cm}]
		\node [n, label=humidity] (M1) {$M_1$};
		\node [n, below = 1cm of M1, label=temperature] (M2) {$M_2$};
		\node [n, below = 1cm of M2, label=air pressure] (M3) {$M_3$};
		\node [n, right = 2cm of M1, label=weather station] (S1) {$S_1$};
		\draw [->] (M1) -- (S1) (M2) -| ($ (M2) !.5! (S1) $) |- (S1) (M3) -| ($ (M3) !.5! (S1) $) |- (S1);
		\node [n, below = 1cm of S1] (S2) {$S_2$};
		\node [n, below = 1cm of S2] (S3) {$S_3$};
		\node [n, right = 3cm of S2, label=Prometheus] (P) {$P$};
		\draw [->] (S1) -- (P);
		\draw [->](S2) -- (P);
		\draw [->] (S3) -- (P);
		\node [n, right = 2cm of P, label=Grafana] (G) {$G$};
		\draw [->] (P) -- (G);
	\end{tikzpicture}
	\caption{Example of a Small Monitoring System}
	\label{fig:system}
\end{figure}

\begin{samepage}
\section{Abstraction}
\label{sec:abstraction}
In the abstraction layer the same approach can be used. First the real world situation has to be modeled and then the digital components.

\subsection{Real World Abstraction}

As mentioned earlier a sensor can be anything and is a physical device which measures all kinds of metrics. A simple model can be visualized in the following way:

\begin{figure}[h!]
	\centering
	\begin{tikzpicture}[n/.style={draw,thick,circle,inner sep=0pt,minimum width=1cm}]
		\node [n,inner sep=1mm] (M1) {$Metric$};
		\node [n,inner sep=1mm, left = 4cm of M1] (S1) {$Sensor$};
		\path [] 
		(S1) edge node[above, pos=0.85] {1..n} node[above, pos=0.15] {1..n} (M1);
	\end{tikzpicture}
	\caption{Abstract Model of a Sensordevice}
\end{figure}
\end{samepage}
\noindent
As shown a sensor can have 1\dots n metrics.

\subsection{Digital World Abstraction}

The transition of the digital situation into a abstract model is very linear and simple. Like in image \ref{fig:system} Grafana knows Prometheus which crawls the data of the sensors.

\begin{samepage}
\begin{figure}[h!]
	\centering
	\begin{tikzpicture}[n/.style={draw,thick,circle,inner sep=0pt,minimum width=1cm}]
		\node [n,inner sep=1mm] (S1) {$Sensor$};
		\node [n,inner sep=1mm, left = 3cm of S1] (P1) {$Prometheus$};
		\node [n,inner sep=1mm, left = 3cm of P1] (G1) {$Grafana$};
		\path [] 
			(G1) edge node[above, pos=0.85] {1} node[above, pos=0.15] {1} (P1)
			(P1) edge node[above, pos=0.85] {1..n} node[above, pos=0.15] {1} (S1)
			;
	\end{tikzpicture}
	\caption{Abstract Model of the Digital Components}
\end{figure}
\end{samepage}

The simple abstraction above shows the technical dependency and the data flow. Yet it does not consider every property which is configurable in Prometheus and Grafana. Furthermore it overlooks the meta information coming from the real world setting.

\subsection{Specification}
The abstraction in \autoref{sec:abstraction} is very basic and fundamental. Since there are more variables to take care of the model has to be extended. Due to the variety of the sensors and no option of a central management all additional configurations are done in Prometheus or Grafana.

\subsubsection{Location}
A location information is missing. Technically it can be added in each entry of the sensor in the Prometheus configuration as an additional label which will then be added as a keyword in the exported metrics. 

\begin{listing}[H]
	\begin{minted}[mathescape,linenos,numbersep=5pt,gobble=0,frame=lines,tabsize=4,breaklines,framesep=2mm]{yaml}
- job_name: '«sensor.name»'
  static_configs:
  - targets: ['«sensor.url»']
    labels:
      location: '«sensor.location»'
	\end{minted}
	\caption{Generic Sensor Configuration for Prometheus~\cite{PrometheusExpositionFormatBeispiel}}
\end{listing}

\subsubsection{Grouping of sensors}
To have a better management experience a grouping for the sensors should be introduced. It would be possible to group them via labels or metric name but this could lead to a not fully understandable networking. 

\begin{samepage}
	\begin{figure}[h!]
		\centering
		\begin{tikzpicture}[n/.style={draw,thick,circle,inner sep=0pt,minimum width=1cm}]
			\node [n,inner sep=1mm] (S1) {$sensor$};
			\node [n,inner sep=1mm, left = 3cm of S1] (P1) {$sensor group$};
			\path [] 
			(P1) edge node[above, pos=0.85] {1..n} node[above, pos=0.15] {1..n} (S1)
			;
		\end{tikzpicture}
		\caption{Abstract Model of Sensor Grouping}
	\end{figure}
\end{samepage}


\subsubsection{Prometheus Query Language}
Since one goal of this thesis is to create an abstract model of all needed configurations in Prometheus and Grafana, \gls{promql} is one important thing to be considered. Modeling a \gls{promql} query should also be possible. Vector aggregation, set operations and so on are features to be covered. 


\section{Model}

Building a \gls{dsl} on top of the previous considerations leads to a well designed model. The explanations start bottom-up which equals the development process for the user of the created \gls{dsl}. For a better overview a separation of all informational layers is needed.

The elemental components are the measurable metrics. They have a simple name and an optional unit like \gls{w}, \gls{degreeC} or \gls{percent}. A subset of the defined metrics are part of a sensor.

In the next layer the sensors are instantiated, connected with a location and combined with a handful of properties. A name and a \gls{url} of the sensor is essential. This information is needed for the configuration generation for the Prometheus service, allowing it to pull the sensor date frequently and save it in the internal database. On top, allowing an easier management sensor groups are introduced, combining multiple sensors into one node. Therefore this layer serves the spatial allocation. 

After modeling the real world situation the next layer models the Grafana service. The available sensors and sensor groups can now be used in a \gls{promql} $GraphQuery$ node. This node form the base data set for additional query selections. Technically \gls{promql} allows a high variety of different queries but for the sake of less complexity a single application of a aggregation function is allowed. Additionally \gls{promql} queries can take information for features like resolution, time window or offset. 

The defined queries can now be bundled in different Grafana panels allowing to share these queries between panels. A panel has a visualization type and matching settings for example for highest value of an axis, linear or logarithmic grid, colors or special rules for single values. No matter the type every panel has a width, height, x- and y- position based on the Grafana \gls{ui} system. This information allows to manage the panels inside a dashboard, which is the last node type of the Grafana layer. It consists of a name and a unique short string identifier which is needed for Grafana. 

Last but not least the project layer is more of the business and controlling view. The only node existing here is the project node. It can contain different meta variables welding useful information for further execution of the project like address, company name, deployment type or important \glspl{IP} addresses. 

In retrospective the model is mostly linear, leaving a straight forward way of working with the \gls{dsl} implementing this model. The separation into the four layers help the developer or engineer to think in well defined domains. They symbolize the steps of defining the used sensors, placing and grouping them in the real world and setting up the visualization for Grafana. Like already said the last layer is only used for meta data concerning the project itself.

\begin{figure}[!tb]
	\centering
	\begin{tikzpicture}[ state/.style={draw,minimum height=\ht\strutbox+\dp\strutbox, inner ysep=0pt}, label/.style={minimum height=\ht\strutbox+\dp\strutbox, inner ysep=0pt}]
		
		\node[] (bb1) {$\textbf{Layers:}$};
		\node[below=of bb1] (bb2) {$\textbf{Submodel:}$};
		\node[label, right=of bb1] (b1) {Sensor};
		\node[label, right=2cm of b1] (b2) {Floor};
		\node[label, right=2cm of b2] (b3) {Grafana};
		\node[label, right=2cm of b3] (b4) {Project};
		%\path[] (b1) edge (b2) (b2) edge (b3) (b3) edge (b4);
		
		\node[state, below=of b1] (a1) {Metrics};
		\node[state, below=of a1] (a2) {Sensor};
		\node[state, below=of b2] (aa3) {Location};
		\node[state, below=of aa3] (a3) {SensorInstance};
		\node[state, below=of a3] (a4) {SensorGroup};
		\node[state, below=of b3] (a5) {GraphQuery};
		\node[state, below=of a5] (a6) {QueryParameters};
		\node[state, below=of a6] (a7) {Panel};
		\node[state, below=of a7] (a8) {Dashboard};
		\node[state, below=of b4] (a9) {Project};
		\path[] 
			(a1) edge (a2)
			(a2) edge (a3)
			(aa3) edge (a3)
			(a3) edge (a4)
			(a3) edge (a5)
			(a4) edge (a5)
			(a5) edge (a6)
			(a6) edge (a7)
			(a7) edge (a8)
			(a8) edge (a9)
			;
		\coordinate (c1) at ($(b1) ! .5 ! (a1)$);
		\coordinate (c2) at ($(b4) ! .5 ! (a9)$);
		\path (c1) ++(-1,0) coordinate (c3);
		\path (c2) ++(1,0) coordinate (c4);
		\path (c3) edge (c4);
		\path ($(b1)!.5!(b2)$) ++(0,0.5) coordinate (c5) edge[gray] ++(0,-8);
		\path ($(b2)!.5!(b3)$) ++(0,0.5) coordinate (c6) edge[gray] ++(0,-8);
		\path ($(b3)!.5!(b4)$) ++(0,0.5) coordinate (c7) edge[gray] ++(0,-8);
	\end{tikzpicture}
	\caption{Dependency of Model Layers}
	\label{fig:ModelLayers}
\end{figure}
\todo{add cardinalities in fig.}

\subsection{Model Validation}
For the replenishment of the model some constraints have to be added separately. Many of them are already fulfilled under regard of the annotated cardinality in the model. Iterating through layers and nodes the needed conditions will be explained. 

The first constraint is that a sensor can only have a bunch of metrics where they have unique names in the connected subset, because otherwise data collected for that metric label can not be allocated unambiguous therefor leading to incorrect and unusable data. 

Furthermore SensorGroups have the restriction of containing only SensorInstance based on the same Sensor. This will ensure that all data summarized in this node is still consistent and delivering the same information in a plot.

A similar restriction is also needed in the QueryParameters. As it get multiple GraphQuery nodes the same constraint for type uniformity has to be fulfilled.

Panels combine the preceding queries where each query is one function drawn in the panels plot. Here it is necessary to ensure that the unit of measure is the same in all queries. Because this constraint can not enforce to use coherent data, for example, not mixing up temperature from casual living rooms with the that of an oven the plausibility has to be maintained by the person designing a sensor network.

As a organizing part a dashboard contains different panel. This model allows to share panels between dashboard which is not possible using the out of the box functionality of Grafana. The constraints here rely on the layout. The panels are not allowed to overlap or being not in the visible space of the dashboard. Additionally another constrained has to be respected. Every Dashboard has to own a unique identifier. Grafana uses them for internal purposes and multiple dashboards sharing the same id are not functional.



